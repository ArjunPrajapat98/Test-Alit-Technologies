{"ast":null,"code":"import { constant } from \"./constant\";\nArray.prototype.mapWithKey = function (callback) {\n  let newArray = [];\n  for (let index = 0; index < this.length; index++) {\n    let counter = callback(this[index], JSON.stringify(this[index]), index, this);\n    newArray.push(counter);\n  }\n  return newArray;\n};\nexport const utils = {\n  isEqualObject: (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2),\n  isObjectValueEmpty: obj => Object.values(obj).every(item => item !== \"\" || item !== \"undefined\" || item !== undefined) ? true : false,\n  isObjectKeyEmpty: obj => Object.keys(obj).length ? false : true,\n  isObjectKeyExist: (obj, key) => Object.keys(obj).includes(key),\n  checkFormError: async (inputValue, schema) => {\n    try {\n      const validationResult = await schema.validate(inputValue, {\n        abortEarly: false\n      });\n      return !!validationResult;\n    } catch (error) {\n      var _error$inner;\n      let obj = {};\n      error === null || error === void 0 ? void 0 : (_error$inner = error.inner) === null || _error$inner === void 0 ? void 0 : _error$inner.forEach(vr => {\n        obj[vr.path] = vr.errors[0];\n      });\n      return obj;\n    }\n  },\n  getResposeError: resError => {\n    let error = \"\";\n    if (typeof resError === \"string\") {\n      error = resError;\n    } else {\n      for (const key in resError) {\n        if (Object.hasOwnProperty.call(resError, key)) {\n          error = typeof resError[key] === \"string\" ? resError[key] : resError[key][0];\n        }\n      }\n    }\n    return error;\n  },\n  getResponseAllErrors: resError => {\n    let error = {};\n    for (const key in resError) {\n      if (Object.hasOwnProperty.call(resError, key)) {\n        error[key] = resError[key][0];\n      }\n    }\n    return error;\n  },\n  queryString: params => Object.keys(params).map(key => key + \"=\" + params[key]).join(\"&\"),\n  spliceString: (text = \"\",\n  // string\n  start = 0,\n  // index\n  end = 0,\n  // index\n  join = \"\",\n  // character\n  from = \"\",\n  // character\n  to = 0 //lenght or count\n  ) => {\n    if (from !== \"\") {\n      let ind = text.indexOf(\".\");\n      return text.slice(start, end > ind ? ind : end) + join + text.slice(ind, text.length);\n    } else {\n      return text === null || text === void 0 ? void 0 : text.slice(start, end);\n    }\n  },\n  firstLetterCapital: (word = \"\") => (word === null || word === void 0 ? void 0 : word.length) > 1 ? (word === null || word === void 0 ? void 0 : word.charAt(0).toUpperCase()) + (word === null || word === void 0 ? void 0 : word.slice(1)) : word === null || word === void 0 ? void 0 : word.toUpperCase(),\n  capitalFirstLetter: (word = \"\") => (word === null || word === void 0 ? void 0 : word.length) > 1 ? word === null || word === void 0 ? void 0 : word.charAt(0).toUpperCase() : \"NA\",\n  convertParseFloat: num => num != 0 ? parseFloat(num).toFixed(2).replace(/\\.00$/, \"\") : num,\n  lengthBeforeDecimal: number => {\n    const numberStr = number.toString();\n    const decimalIndex = numberStr.indexOf(\".\");\n    if (decimalIndex === -1) {\n      return numberStr.length;\n    } else {\n      return decimalIndex;\n    }\n  },\n  formatDate: (date = \"\") => {\n    if (!date) {\n      return \"\";\n    }\n    const newDate = new Date(date);\n    const year = newDate.getFullYear();\n    const month = String(newDate.getMonth() + 1).padStart(2, \"0\");\n    const day = String(newDate.getDate()).padStart(2, \"0\");\n    return `${day}/${month}/${year}`;\n  }\n};","map":{"version":3,"names":["constant","Array","prototype","mapWithKey","callback","newArray","index","length","counter","JSON","stringify","push","utils","isEqualObject","obj1","obj2","isObjectValueEmpty","obj","Object","values","every","item","undefined","isObjectKeyEmpty","keys","isObjectKeyExist","key","includes","checkFormError","inputValue","schema","validationResult","validate","abortEarly","error","_error$inner","inner","forEach","vr","path","errors","getResposeError","resError","hasOwnProperty","call","getResponseAllErrors","queryString","params","map","join","spliceString","text","start","end","from","to","ind","indexOf","slice","firstLetterCapital","word","charAt","toUpperCase","capitalFirstLetter","convertParseFloat","num","parseFloat","toFixed","replace","lengthBeforeDecimal","number","numberStr","toString","decimalIndex","formatDate","date","newDate","Date","year","getFullYear","month","String","getMonth","padStart","day","getDate"],"sources":["/home/abc/Documents/alit-task/my-app/src/App/helper/utils.js"],"sourcesContent":["import { constant } from \"./constant\";\n\nArray.prototype.mapWithKey = function (callback) {\n  let newArray = [];\n  for (let index = 0; index < this.length; index++) {\n    let counter = callback(\n      this[index],\n      JSON.stringify(this[index]),\n      index,\n      this\n    );\n    newArray.push(counter);\n  }\n  return newArray;\n};\n\nexport const utils = {\n  isEqualObject: (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2),\n\n  isObjectValueEmpty: (obj) =>\n    Object.values(obj).every(\n      (item) => item !== \"\" || item !== \"undefined\" || item !== undefined\n    )\n      ? true\n      : false,\n\n  isObjectKeyEmpty: (obj) => (Object.keys(obj).length ? false : true),\n  isObjectKeyExist: (obj, key) => Object.keys(obj).includes(key),\n\n  checkFormError: async (inputValue, schema) => {\n    try {\n      const validationResult = await schema.validate(inputValue, {\n        abortEarly: false,\n      });\n      return !!validationResult;\n    } catch (error) {\n      let obj = {};\n      error?.inner?.forEach((vr) => {\n        obj[vr.path] = vr.errors[0];\n      });\n      return obj;\n    }\n  },\n  getResposeError: (resError) => {\n    let error = \"\";\n    if (typeof resError === \"string\") {\n      error = resError;\n    } else {\n      for (const key in resError) {\n        if (Object.hasOwnProperty.call(resError, key)) {\n          error =\n            typeof resError[key] === \"string\"\n              ? resError[key]\n              : resError[key][0];\n        }\n      }\n    }\n    return error;\n  },\n\n  getResponseAllErrors: (resError) => {\n    let error = {};\n    for (const key in resError) {\n      if (Object.hasOwnProperty.call(resError, key)) {\n        error[key] = resError[key][0];\n      }\n    }\n    return error;\n  },\n\n  queryString: (params) =>\n    Object.keys(params)\n      .map((key) => key + \"=\" + params[key])\n      .join(\"&\"),\n\n  spliceString: (\n    text = \"\", // string\n    start = 0, // index\n    end = 0, // index\n    join = \"\", // character\n    from = \"\", // character\n    to = 0 //lenght or count\n  ) => {\n    if (from !== \"\") {\n      let ind = text.indexOf(\".\");\n      return (\n        text.slice(start, end > ind ? ind : end) +\n        join +\n        text.slice(ind, text.length)\n      );\n    } else {\n      return text?.slice(start, end);\n    }\n  },\n\n  firstLetterCapital: (word = \"\") =>\n    word?.length > 1\n      ? word?.charAt(0).toUpperCase() + word?.slice(1)\n      : word?.toUpperCase(),\n\n  capitalFirstLetter: (word = \"\") =>\n    word?.length > 1 ? word?.charAt(0).toUpperCase() : \"NA\",\n  convertParseFloat: (num) =>\n    num != 0 ? parseFloat(num).toFixed(2).replace(/\\.00$/, \"\") : num,\n  lengthBeforeDecimal: (number) => {\n    const numberStr = number.toString();\n    const decimalIndex = numberStr.indexOf(\".\");\n    if (decimalIndex === -1) {\n      return numberStr.length;\n    } else {\n      return decimalIndex;\n    }\n  },\n  formatDate: (date = \"\") => {\n    if (!date) {\n      return \"\";\n    }\n    const newDate = new Date(date);\n    const year = newDate.getFullYear();\n    const month = String(newDate.getMonth() + 1).padStart(2, \"0\");\n    const day = String(newDate.getDate()).padStart(2, \"0\");\n\n    return `${day}/${month}/${year}`;\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}