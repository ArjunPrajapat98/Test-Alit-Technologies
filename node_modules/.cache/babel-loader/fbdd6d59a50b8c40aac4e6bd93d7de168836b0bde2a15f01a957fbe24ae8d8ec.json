{"ast":null,"code":"import { constant } from \"./constant\";\nArray.prototype.mapWithKey = function (callback) {\n  let newArray = [];\n  for (let index = 0; index < this.length; index++) {\n    let counter = callback(this[index], JSON.stringify(this[index]), index, this);\n    newArray.push(counter);\n  }\n  return newArray;\n};\nexport const utils = {\n  isEqualObject: (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2),\n  isObjectValueEmpty: obj => Object.values(obj).every(item => item !== \"\" || item !== \"undefined\" || item !== undefined) ? true : false,\n  isObjectKeyEmpty: obj => Object.keys(obj).length ? false : true,\n  isObjectKeyExist: (obj, key) => Object.keys(obj).includes(key),\n  checkFormError: async (inputValue, schema) => {\n    try {\n      const validationResult = await schema.validate(inputValue, {\n        abortEarly: false\n      });\n      return !!validationResult;\n    } catch (error) {\n      var _error$inner;\n      let obj = {};\n      error === null || error === void 0 ? void 0 : (_error$inner = error.inner) === null || _error$inner === void 0 ? void 0 : _error$inner.forEach(vr => {\n        obj[vr.path] = vr.errors[0];\n      });\n      return obj;\n    }\n  },\n  getResposeError: resError => {\n    let error = \"\";\n    if (typeof resError === \"string\") {\n      error = resError;\n    } else {\n      for (const key in resError) {\n        if (Object.hasOwnProperty.call(resError, key)) {\n          error = typeof resError[key] === \"string\" ? resError[key] : resError[key][0];\n        }\n      }\n    }\n    return error;\n  },\n  getResponseAllErrors: resError => {\n    let error = {};\n    for (const key in resError) {\n      if (Object.hasOwnProperty.call(resError, key)) {\n        error[key] = resError[key][0];\n      }\n    }\n    return error;\n  },\n  queryString: params => Object.keys(params).map(key => key + \"=\" + params[key]).join(\"&\"),\n  formatDate: (date = \"\") => {\n    if (!date) {\n      return \"\";\n    }\n    const newDate = new Date(date);\n    const year = newDate.getFullYear();\n    const month = String(newDate.getMonth() + 1).padStart(2, \"0\");\n    const day = String(newDate.getDate()).padStart(2, \"0\");\n    return `${day}/${month}/${year}`;\n  }\n};","map":{"version":3,"names":["constant","Array","prototype","mapWithKey","callback","newArray","index","length","counter","JSON","stringify","push","utils","isEqualObject","obj1","obj2","isObjectValueEmpty","obj","Object","values","every","item","undefined","isObjectKeyEmpty","keys","isObjectKeyExist","key","includes","checkFormError","inputValue","schema","validationResult","validate","abortEarly","error","_error$inner","inner","forEach","vr","path","errors","getResposeError","resError","hasOwnProperty","call","getResponseAllErrors","queryString","params","map","join","formatDate","date","newDate","Date","year","getFullYear","month","String","getMonth","padStart","day","getDate"],"sources":["/home/abc/Documents/alit-task/Test-Alit-Technologies/src/App/helper/utils.js"],"sourcesContent":["import { constant } from \"./constant\";\n\nArray.prototype.mapWithKey = function (callback) {\n  let newArray = [];\n  for (let index = 0; index < this.length; index++) {\n    let counter = callback(\n      this[index],\n      JSON.stringify(this[index]),\n      index,\n      this\n    );\n    newArray.push(counter);\n  }\n  return newArray;\n};\n\nexport const utils = {\n  isEqualObject: (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2),\n\n  isObjectValueEmpty: (obj) =>\n    Object.values(obj).every(\n      (item) => item !== \"\" || item !== \"undefined\" || item !== undefined\n    )\n      ? true\n      : false,\n\n  isObjectKeyEmpty: (obj) => (Object.keys(obj).length ? false : true),\n  isObjectKeyExist: (obj, key) => Object.keys(obj).includes(key),\n\n  checkFormError: async (inputValue, schema) => {\n    try {\n      const validationResult = await schema.validate(inputValue, {\n        abortEarly: false,\n      });\n      return !!validationResult;\n    } catch (error) {\n      let obj = {};\n      error?.inner?.forEach((vr) => {\n        obj[vr.path] = vr.errors[0];\n      });\n      return obj;\n    }\n  },\n  getResposeError: (resError) => {\n    let error = \"\";\n    if (typeof resError === \"string\") {\n      error = resError;\n    } else {\n      for (const key in resError) {\n        if (Object.hasOwnProperty.call(resError, key)) {\n          error =\n            typeof resError[key] === \"string\"\n              ? resError[key]\n              : resError[key][0];\n        }\n      }\n    }\n    return error;\n  },\n\n  getResponseAllErrors: (resError) => {\n    let error = {};\n    for (const key in resError) {\n      if (Object.hasOwnProperty.call(resError, key)) {\n        error[key] = resError[key][0];\n      }\n    }\n    return error;\n  },\n\n  queryString: (params) =>\n    Object.keys(params)\n      .map((key) => key + \"=\" + params[key])\n      .join(\"&\"),\n\n  formatDate: (date = \"\") => {\n    if (!date) {\n      return \"\";\n    }\n    const newDate = new Date(date);\n    const year = newDate.getFullYear();\n    const month = String(newDate.getMonth() + 1).padStart(2, \"0\");\n    const day = String(newDate.getDate()).padStart(2, \"0\");\n\n    return `${day}/${month}/${year}`;\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}